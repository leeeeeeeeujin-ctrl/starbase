-- =========================================
-- Starbase AI Roomchat: Chat & Social Schema
-- =========================================
-- 실행 방법 예시:
--   psql $SUPABASE_DATABASE_URL -f chat-social-schema.sql
-- 또는 Supabase SQL Editor에 그대로 붙여넣어 실행합니다.
--
-- 1) 채팅 메시지 테이블 및 RLS 정책
-- 2) 친구 요청 / 친구 관계 테이블 및 정책
-- 3) 필수 인덱스와 트리거
-- =========================================

-- -----------------------------------------
-- 1. 채팅 메시지
-- -----------------------------------------
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  user_id uuid not null references auth.users(id) on delete cascade,
  owner_id uuid not null references auth.users(id) on delete cascade,
  username text not null,
  avatar_url text,
  hero_id uuid references public.heroes(id) on delete set null,
  scope text not null default 'global',
  target_hero_id uuid references public.heroes(id) on delete set null,
  text text not null check (length(text) between 1 and 2000),
  metadata jsonb
);

alter table public.messages enable row level security;

drop policy if exists messages_select_public on public.messages;
create policy messages_select_public
on public.messages for select
using (true);

drop policy if exists messages_insert_auth on public.messages;
create policy messages_insert_auth
on public.messages for insert to authenticated
with check (
  auth.uid() = user_id
  and owner_id = auth.uid()
);

create index if not exists messages_created_at_desc on public.messages (created_at desc);
create index if not exists messages_scope_created_at on public.messages (scope, created_at desc);
create index if not exists messages_hero_scope_created_at on public.messages (hero_id, scope, created_at desc);
create index if not exists messages_target_scope_created_at on public.messages (target_hero_id, scope, created_at desc);

-- -----------------------------------------
-- 2. 친구 요청 & 친구 관계
-- -----------------------------------------
create table if not exists public.friend_requests (
  id uuid primary key default gen_random_uuid(),
  requester_id uuid not null references auth.users(id) on delete cascade,
  addressee_id uuid not null references auth.users(id) on delete cascade,
  status text not null default 'pending' check (status in ('pending', 'accepted', 'declined', 'cancelled')),
  message text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists friend_requests_addressee_status on public.friend_requests (addressee_id, status);
create index if not exists friend_requests_requester_status on public.friend_requests (requester_id, status);
create unique index if not exists friend_requests_unique_pending
  on public.friend_requests (requester_id, addressee_id)
  where status = 'pending';

alter table public.friend_requests enable row level security;

drop policy if exists friend_requests_select_participants on public.friend_requests;
create policy friend_requests_select_participants
on public.friend_requests for select
using (auth.uid() in (requester_id, addressee_id));

drop policy if exists friend_requests_insert_requester on public.friend_requests;
create policy friend_requests_insert_requester
on public.friend_requests for insert to authenticated
with check (auth.uid() = requester_id);

drop policy if exists friend_requests_update_participants on public.friend_requests;
create policy friend_requests_update_participants
on public.friend_requests for update to authenticated
using (auth.uid() in (requester_id, addressee_id))
with check (auth.uid() in (requester_id, addressee_id));

drop policy if exists friend_requests_delete_participants on public.friend_requests;
create policy friend_requests_delete_participants
on public.friend_requests for delete to authenticated
using (auth.uid() in (requester_id, addressee_id));

create table if not exists public.friendships (
  id uuid primary key default gen_random_uuid(),
  user_id_a uuid not null references auth.users(id) on delete cascade,
  user_id_b uuid not null references auth.users(id) on delete cascade,
  since timestamptz not null default now(),
  created_at timestamptz not null default now(),
  constraint friend_pairs_canonical check (user_id_a < user_id_b)
);

create unique index if not exists friendships_unique_pair
  on public.friendships (user_id_a, user_id_b);

create index if not exists friendships_user_a on public.friendships (user_id_a);
create index if not exists friendships_user_b on public.friendships (user_id_b);

alter table public.friendships enable row level security;

drop policy if exists friendships_select_participants on public.friendships;
create policy friendships_select_participants
on public.friendships for select
using (auth.uid() in (user_id_a, user_id_b));

drop policy if exists friendships_insert_participants on public.friendships;
create policy friendships_insert_participants
on public.friendships for insert to authenticated
with check (auth.uid() in (user_id_a, user_id_b));

drop policy if exists friendships_delete_participants on public.friendships;
create policy friendships_delete_participants
on public.friendships for delete to authenticated
using (auth.uid() in (user_id_a, user_id_b));

-- -----------------------------------------
-- 3. updated_at 자동 갱신 트리거
-- -----------------------------------------
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at := now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists friend_requests_set_updated_at on public.friend_requests;
create trigger friend_requests_set_updated_at
before update on public.friend_requests
for each row
execute function public.set_updated_at();

-- -----------------------------------------
-- 4. 채팅방 공지 & 반응/댓글
-- -----------------------------------------
create table if not exists public.chat_room_announcements (
  id uuid primary key default gen_random_uuid(),
  room_id uuid not null references public.chat_rooms(id) on delete cascade,
  author_id uuid not null references auth.users(id) on delete cascade,
  title text,
  content text not null,
  image_url text,
  pinned boolean not null default false,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.chat_room_announcement_reactions (
  announcement_id uuid not null references public.chat_room_announcements(id) on delete cascade,
  owner_id uuid not null references auth.users(id) on delete cascade,
  reaction text not null default 'heart',
  created_at timestamptz not null default timezone('utc', now()),
  primary key (announcement_id, owner_id)
);

create table if not exists public.chat_room_announcement_comments (
  id uuid primary key default gen_random_uuid(),
  announcement_id uuid not null references public.chat_room_announcements(id) on delete cascade,
  owner_id uuid not null references auth.users(id) on delete cascade,
  content text not null,
  created_at timestamptz not null default timezone('utc', now())
);

alter table public.chat_room_announcements enable row level security;
alter table public.chat_room_announcement_reactions enable row level security;
alter table public.chat_room_announcement_comments enable row level security;

drop policy if exists chat_room_announcements_select on public.chat_room_announcements;
create policy chat_room_announcements_select
on public.chat_room_announcements for select
using (
  exists (
    select 1
    from public.chat_room_members mem
    where mem.room_id = chat_room_announcements.room_id
      and mem.owner_id = auth.uid()
      and coalesce(mem.status, 'active') = 'active'
  )
  or exists (
    select 1
    from public.chat_room_moderators m
    where m.room_id = chat_room_announcements.room_id
      and m.owner_id = auth.uid()
  )
  or exists (
    select 1
    from public.chat_rooms r
    where r.id = chat_room_announcements.room_id
      and r.owner_id = auth.uid()
  )
);

drop policy if exists chat_room_announcements_mutate on public.chat_room_announcements;
create policy chat_room_announcements_mutate
on public.chat_room_announcements for all to authenticated
using (
  exists (
    select 1
    from public.chat_rooms r
    where r.id = chat_room_announcements.room_id
      and r.owner_id = auth.uid()
  )
  or exists (
    select 1
    from public.chat_room_moderators m
    where m.room_id = chat_room_announcements.room_id
      and m.owner_id = auth.uid()
  )
)
with check (
  exists (
    select 1
    from public.chat_rooms r
    where r.id = chat_room_announcements.room_id
      and r.owner_id = auth.uid()
  )
  or exists (
    select 1
    from public.chat_room_moderators m
    where m.room_id = chat_room_announcements.room_id
      and m.owner_id = auth.uid()
  )
);

drop policy if exists chat_room_announcement_reactions_select on public.chat_room_announcement_reactions;
create policy chat_room_announcement_reactions_select
on public.chat_room_announcement_reactions for select
using (
  exists (
    select 1
    from public.chat_room_announcements a
    where a.id = chat_room_announcement_reactions.announcement_id
      and (
        exists (
          select 1
          from public.chat_room_members mem
          where mem.room_id = a.room_id
            and mem.owner_id = auth.uid()
            and coalesce(mem.status, 'active') = 'active'
        )
        or exists (
          select 1
          from public.chat_room_moderators m
          where m.room_id = a.room_id
            and m.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_rooms r
          where r.id = a.room_id
            and r.owner_id = auth.uid()
        )
      )
  )
);

drop policy if exists chat_room_announcement_reactions_mutate on public.chat_room_announcement_reactions;
create policy chat_room_announcement_reactions_mutate
on public.chat_room_announcement_reactions for all to authenticated
using (
  exists (
    select 1
    from public.chat_room_announcements a
    where a.id = chat_room_announcement_reactions.announcement_id
      and (
        exists (
          select 1
          from public.chat_rooms r
          where r.id = a.room_id
            and r.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_room_moderators m
          where m.room_id = a.room_id
            and m.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_room_members mem
          where mem.room_id = a.room_id
            and mem.owner_id = auth.uid()
            and coalesce(mem.status, 'active') = 'active'
        )
      )
  )
)
with check (
  exists (
    select 1
    from public.chat_room_announcements a
    where a.id = chat_room_announcement_reactions.announcement_id
      and (
        exists (
          select 1
          from public.chat_rooms r
          where r.id = a.room_id
            and r.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_room_moderators m
          where m.room_id = a.room_id
            and m.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_room_members mem
          where mem.room_id = a.room_id
            and mem.owner_id = auth.uid()
            and coalesce(mem.status, 'active') = 'active'
        )
      )
  )
);

drop policy if exists chat_room_announcement_comments_select on public.chat_room_announcement_comments;
create policy chat_room_announcement_comments_select
on public.chat_room_announcement_comments for select
using (
  exists (
    select 1
    from public.chat_room_announcements a
    where a.id = chat_room_announcement_comments.announcement_id
      and (
        exists (
          select 1
          from public.chat_room_members mem
          where mem.room_id = a.room_id
            and mem.owner_id = auth.uid()
            and coalesce(mem.status, 'active') = 'active'
        )
        or exists (
          select 1
          from public.chat_room_moderators m
          where m.room_id = a.room_id
            and m.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_rooms r
          where r.id = a.room_id
            and r.owner_id = auth.uid()
        )
      )
  )
);

drop policy if exists chat_room_announcement_comments_mutate on public.chat_room_announcement_comments;
create policy chat_room_announcement_comments_mutate
on public.chat_room_announcement_comments for all to authenticated
using (
  exists (
    select 1
    from public.chat_room_announcements a
    where a.id = chat_room_announcement_comments.announcement_id
      and (
        exists (
          select 1
          from public.chat_rooms r
          where r.id = a.room_id
            and r.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_room_moderators m
          where m.room_id = a.room_id
            and m.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_room_members mem
          where mem.room_id = a.room_id
            and mem.owner_id = auth.uid()
            and coalesce(mem.status, 'active') = 'active'
        )
      )
  )
)
with check (
  exists (
    select 1
    from public.chat_room_announcements a
    where a.id = chat_room_announcement_comments.announcement_id
      and (
        exists (
          select 1
          from public.chat_rooms r
          where r.id = a.room_id
            and r.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_room_moderators m
          where m.room_id = a.room_id
            and m.owner_id = auth.uid()
        )
        or exists (
          select 1
          from public.chat_room_members mem
          where mem.room_id = a.room_id
            and mem.owner_id = auth.uid()
            and coalesce(mem.status, 'active') = 'active'
        )
      )
  )
);

create index if not exists chat_room_announcements_room_idx
  on public.chat_room_announcements (room_id, created_at desc);
create index if not exists chat_room_announcement_comments_ann_idx
  on public.chat_room_announcement_comments (announcement_id, created_at desc);
create index if not exists chat_room_announcement_reactions_ann_idx
  on public.chat_room_announcement_reactions (announcement_id, owner_id);

create or replace function public.touch_chat_room_announcement()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := timezone('utc', now());
  return new;
end;
$$;

drop trigger if exists trg_chat_room_announcements_touch on public.chat_room_announcements;
create trigger trg_chat_room_announcements_touch
before update on public.chat_room_announcements
for each row
execute function public.touch_chat_room_announcement();

drop function if exists public.fetch_chat_room_announcements(uuid, integer, timestamptz);
create or replace function public.fetch_chat_room_announcements(
  p_room_id uuid,
  p_limit integer default 20,
  p_cursor timestamptz default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid := auth.uid();
  v_can_view boolean := false;
  v_limit integer := greatest(5, least(coalesce(p_limit, 20), 100));
  v_cursor timestamptz := p_cursor;
  v_pinned jsonb := null;
  v_announcements jsonb := '[]'::jsonb;
  v_has_more boolean := false;
begin
  if v_actor is null then
    return jsonb_build_object('announcements', '[]'::jsonb, 'pinned', null, 'hasMore', false);
  end if;

  select exists (
      select 1 from public.chat_rooms r
      where r.id = p_room_id
        and r.owner_id = v_actor
    )
    or exists (
      select 1 from public.chat_room_moderators m
      where m.room_id = p_room_id
        and m.owner_id = v_actor
    )
    or exists (
      select 1 from public.chat_room_members mem
      where mem.room_id = p_room_id
        and mem.owner_id = v_actor
        and coalesce(mem.status, 'active') = 'active'
    )
    into v_can_view;

  if not v_can_view then
    return jsonb_build_object('announcements', '[]'::jsonb, 'pinned', null, 'hasMore', false);
  end if;

  select to_jsonb(row)
    into v_pinned
  from (
    select
      a.id,
      a.room_id,
      a.title,
      a.content,
      a.image_url,
      a.pinned,
      a.created_at,
      a.updated_at,
      a.author_id,
      u.raw_user_meta_data->>'full_name' as author_name,
      u.email as author_email,
      (select count(*) from public.chat_room_announcement_reactions r where r.announcement_id = a.id) as heart_count,
      (select count(*) from public.chat_room_announcement_comments c where c.announcement_id = a.id) as comment_count,
      exists (
        select 1
        from public.chat_room_announcement_reactions r
        where r.announcement_id = a.id
          and r.owner_id = v_actor
      ) as viewer_reacted
    from public.chat_room_announcements a
    left join auth.users u on u.id = a.author_id
    where a.room_id = p_room_id
      and a.pinned
    order by a.updated_at desc, a.created_at desc
    limit 1
  ) as row;

  if v_cursor is null then
    if v_pinned is not null then
      v_cursor := greatest((v_pinned->>'updated_at')::timestamptz, (v_pinned->>'created_at')::timestamptz);
    else
      v_cursor := timezone('utc', now());
    end if;
  end if;

  with rows as (
    select
      a.id,
      a.room_id,
      a.title,
      a.content,
      a.image_url,
      a.pinned,
      a.created_at,
      a.updated_at,
      a.author_id,
      u.raw_user_meta_data->>'full_name' as author_name,
      u.email as author_email,
      (select count(*) from public.chat_room_announcement_reactions r where r.announcement_id = a.id) as heart_count,
      (select count(*) from public.chat_room_announcement_comments c where c.announcement_id = a.id) as comment_count,
      exists (
        select 1
        from public.chat_room_announcement_reactions r
        where r.announcement_id = a.id
          and r.owner_id = v_actor
      ) as viewer_reacted
    from public.chat_room_announcements a
    left join auth.users u on u.id = a.author_id
    where a.room_id = p_room_id
      and (not a.pinned or v_pinned is null or a.id <> (v_pinned->>'id')::uuid)
      and a.updated_at <= v_cursor
    order by a.updated_at desc, a.created_at desc
    limit v_limit + 1
  )
  select coalesce(jsonb_agg(to_jsonb(rows)), '[]'::jsonb)
    into v_announcements
  from rows;

  if jsonb_array_length(v_announcements) > v_limit then
    v_announcements := v_announcements - (jsonb_array_length(v_announcements) - 1);
    v_has_more := true;
  end if;

  return jsonb_build_object(
    'announcements', v_announcements,
    'pinned', v_pinned,
    'hasMore', v_has_more
  );
end;
$$;

grant execute on function public.fetch_chat_room_announcements(uuid, integer, timestamptz)
to authenticated;

drop function if exists public.fetch_chat_room_announcement_detail(uuid);
create or replace function public.fetch_chat_room_announcement_detail(
  p_announcement_id uuid
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid := auth.uid();
  v_room_id uuid;
  v_can_view boolean := false;
  v_announcement jsonb := null;
  v_comments jsonb := '[]'::jsonb;
begin
  if v_actor is null then
    return jsonb_build_object('announcement', null, 'comments', '[]'::jsonb);
  end if;

  select room_id
    into v_room_id
  from public.chat_room_announcements
  where id = p_announcement_id;

  if v_room_id is null then
    return jsonb_build_object('announcement', null, 'comments', '[]'::jsonb);
  end if;

  select exists (
      select 1 from public.chat_rooms r
      where r.id = v_room_id
        and r.owner_id = v_actor
    )
    or exists (
      select 1 from public.chat_room_moderators m
      where m.room_id = v_room_id
        and m.owner_id = v_actor
    )
    or exists (
      select 1 from public.chat_room_members mem
      where mem.room_id = v_room_id
        and mem.owner_id = v_actor
        and coalesce(mem.status, 'active') = 'active'
    )
    into v_can_view;

  if not v_can_view then
    return jsonb_build_object('announcement', null, 'comments', '[]'::jsonb);
  end if;

  select to_jsonb(row)
    into v_announcement
  from (
    select
      a.id,
      a.room_id,
      a.title,
      a.content,
      a.image_url,
      a.pinned,
      a.created_at,
      a.updated_at,
      a.author_id,
      u.raw_user_meta_data->>'full_name' as author_name,
      u.email as author_email,
      (select count(*) from public.chat_room_announcement_reactions r where r.announcement_id = a.id) as heart_count,
      (select count(*) from public.chat_room_announcement_comments c where c.announcement_id = a.id) as comment_count,
      exists (
        select 1
        from public.chat_room_announcement_reactions r
        where r.announcement_id = a.id
          and r.owner_id = v_actor
      ) as viewer_reacted
    from public.chat_room_announcements a
    left join auth.users u on u.id = a.author_id
    where a.id = p_announcement_id
  ) as row;

  with comment_rows as (
    select
      c.id,
      c.announcement_id,
      c.owner_id,
      c.content,
      c.created_at,
      u.raw_user_meta_data->>'full_name' as owner_name,
      u.email as owner_email
    from public.chat_room_announcement_comments c
    left join auth.users u on u.id = c.owner_id
    where c.announcement_id = p_announcement_id
    order by c.created_at asc, c.id asc
    limit 200
  )
  select coalesce(jsonb_agg(to_jsonb(comment_rows)), '[]'::jsonb)
    into v_comments
  from comment_rows;

  return jsonb_build_object('announcement', v_announcement, 'comments', v_comments);
end;
$$;

grant execute on function public.fetch_chat_room_announcement_detail(uuid)
to authenticated;

drop function if exists public.create_chat_room_announcement(uuid, text, boolean);
drop function if exists public.create_chat_room_announcement(uuid, text, text, boolean);
drop function if exists public.create_chat_room_announcement(uuid, text, text, text, boolean);
create or replace function public.create_chat_room_announcement(
  p_room_id uuid,
  p_content text,
  p_title text default null,
  p_image_url text default null,
  p_pinned boolean default false
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid := auth.uid();
  v_can_manage boolean := false;
  v_title text := null;
  v_content text := coalesce(p_content, '');
  v_image text := null;
  v_row jsonb := null;
begin
  if v_actor is null then
    return jsonb_build_object('ok', false, 'error', 'not_authenticated');
  end if;

  v_content := trim(v_content);
  if v_content = '' then
    return jsonb_build_object('ok', false, 'error', 'missing_content');
  end if;

  v_title := nullif(trim(coalesce(p_title, '')), '');
  v_image := nullif(trim(coalesce(p_image_url, '')), '');

  select exists (
      select 1 from public.chat_rooms r
      where r.id = p_room_id
        and r.owner_id = v_actor
    )
    or exists (
      select 1 from public.chat_room_moderators m
      where m.room_id = p_room_id
        and m.owner_id = v_actor
    )
    into v_can_manage;

  if not v_can_manage then
    return jsonb_build_object('ok', false, 'error', 'forbidden');
  end if;

  insert into public.chat_room_announcements (room_id, author_id, title, content, image_url, pinned)
  values (p_room_id, v_actor, v_title, v_content, v_image, coalesce(p_pinned, false))
  returning jsonb_build_object(
    'id', id,
    'room_id', room_id,
    'author_id', author_id,
    'title', title,
    'content', content,
    'image_url', image_url,
    'pinned', pinned,
    'created_at', created_at,
    'updated_at', updated_at
  ) into v_row;

  if p_pinned then
    update public.chat_room_announcements
    set pinned = false
    where room_id = p_room_id
      and id <> (v_row->>'id')::uuid
      and pinned;
  end if;

  return jsonb_build_object('ok', true, 'announcement', v_row);
end;
$$;

grant execute on function public.create_chat_room_announcement(uuid, text, text, text, boolean)
to authenticated;

drop function if exists public.delete_chat_room_announcement(uuid);
create or replace function public.delete_chat_room_announcement(
  p_announcement_id uuid
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid := auth.uid();
  v_room_id uuid := null;
  v_owner uuid := null;
  v_is_moderator boolean := false;
begin
  if v_actor is null then
    return jsonb_build_object('ok', false, 'error', 'not_authenticated');
  end if;

  select room_id, author_id
    into v_room_id, v_owner
  from public.chat_room_announcements
  where id = p_announcement_id;

  if v_room_id is null then
    return jsonb_build_object('ok', false, 'error', 'not_found');
  end if;

  select exists (
      select 1 from public.chat_rooms r
      where r.id = v_room_id
        and r.owner_id = v_actor
    )
    or exists (
      select 1 from public.chat_room_moderators m
      where m.room_id = v_room_id
        and m.owner_id = v_actor
    )
    into v_is_moderator;

  if not v_is_moderator and v_owner <> v_actor then
    return jsonb_build_object('ok', false, 'error', 'forbidden');
  end if;

  delete from public.chat_room_announcement_reactions
  where announcement_id = p_announcement_id;

  delete from public.chat_room_announcement_comments
  where announcement_id = p_announcement_id;

  delete from public.chat_room_announcements
  where id = p_announcement_id;

  return jsonb_build_object('ok', true);
end;
$$;

grant execute on function public.delete_chat_room_announcement(uuid)
to authenticated;

drop function if exists public.toggle_chat_room_announcement_reaction(uuid);
create or replace function public.toggle_chat_room_announcement_reaction(
  p_announcement_id uuid
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid := auth.uid();
  v_room_id uuid := null;
  v_has_reacted boolean := false;
begin
  if v_actor is null then
    return jsonb_build_object('ok', false, 'error', 'not_authenticated');
  end if;

  select room_id
    into v_room_id
  from public.chat_room_announcements
  where id = p_announcement_id;

  if v_room_id is null then
    return jsonb_build_object('ok', false, 'error', 'not_found');
  end if;

  if not exists (
    select 1
    from public.chat_room_members mem
    where mem.room_id = v_room_id
      and mem.owner_id = v_actor
      and coalesce(mem.status, 'active') = 'active'
  ) and not exists (
    select 1
    from public.chat_room_moderators m
    where m.room_id = v_room_id
      and m.owner_id = v_actor
  ) and not exists (
    select 1
    from public.chat_rooms r
    where r.id = v_room_id
      and r.owner_id = v_actor
  ) then
    return jsonb_build_object('ok', false, 'error', 'forbidden');
  end if;

  select exists (
      select 1
      from public.chat_room_announcement_reactions r
      where r.announcement_id = p_announcement_id
        and r.owner_id = v_actor
    )
    into v_has_reacted;

  if v_has_reacted then
    delete from public.chat_room_announcement_reactions
    where announcement_id = p_announcement_id
      and owner_id = v_actor;
  else
    insert into public.chat_room_announcement_reactions (announcement_id, owner_id)
    values (p_announcement_id, v_actor)
    on conflict (announcement_id, owner_id) do nothing;
  end if;

  return jsonb_build_object('ok', true, 'reacted', not v_has_reacted);
end;
$$;

grant execute on function public.toggle_chat_room_announcement_reaction(uuid)
to authenticated;

drop function if exists public.create_chat_room_announcement_comment(uuid, text);
create or replace function public.create_chat_room_announcement_comment(
  p_announcement_id uuid,
  p_content text
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_actor uuid := auth.uid();
  v_room_id uuid := null;
  v_content text := coalesce(trim(p_content), '');
  v_row jsonb := null;
begin
  if v_actor is null then
    return jsonb_build_object('ok', false, 'error', 'not_authenticated');
  end if;

  if v_content = '' then
    return jsonb_build_object('ok', false, 'error', 'missing_content');
  end if;

  select room_id
    into v_room_id
  from public.chat_room_announcements
  where id = p_announcement_id;

  if v_room_id is null then
    return jsonb_build_object('ok', false, 'error', 'not_found');
  end if;

  if not exists (
    select 1
    from public.chat_room_members mem
    where mem.room_id = v_room_id
      and mem.owner_id = v_actor
      and coalesce(mem.status, 'active') = 'active'
  ) and not exists (
    select 1
    from public.chat_room_moderators m
    where m.room_id = v_room_id
      and m.owner_id = v_actor
  ) and not exists (
    select 1
    from public.chat_rooms r
    where r.id = v_room_id
      and r.owner_id = v_actor
  ) then
    return jsonb_build_object('ok', false, 'error', 'forbidden');
  end if;

  insert into public.chat_room_announcement_comments (announcement_id, owner_id, content)
  values (p_announcement_id, v_actor, v_content)
  returning jsonb_build_object(
    'id', id,
    'announcement_id', announcement_id,
    'owner_id', owner_id,
    'content', content,
    'created_at', created_at
  ) into v_row;

  return jsonb_build_object('ok', true, 'comment', v_row);
end;
$$;

grant execute on function public.create_chat_room_announcement_comment(uuid, text)
to authenticated;

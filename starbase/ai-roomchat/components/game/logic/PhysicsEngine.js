/**
 * üéØ PhysicsEngine - Ï∂©Îèå Í∞êÏßÄ, Ïù¥Îèô, Ï§ëÎ†• Îì± Î¨ºÎ¶¨ Ïó∞ÏÇ∞
 * 
 * ÏàúÏàò Ìï®Ïàò Í∏∞Î∞ò Î¨ºÎ¶¨ ÏãúÏä§ÌÖúÏúºÎ°ú Í≤åÏûÑ ÏóîÌã∞Ìã∞Ïùò Î¨ºÎ¶¨Ï†Å ÏÉÅÌò∏ÏûëÏö©ÏùÑ Ï≤òÎ¶¨Ìï©ÎãàÎã§.
 * ÏÑ±Îä• ÏµúÏ†ÅÌôîÎ•º ÏúÑÌïú Í≥µÍ∞Ñ Î∂ÑÌï† Î∞è Ï∂©Îèå Í∞êÏßÄ ÏïåÍ≥†Î¶¨Ï¶òÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.
 * 
 * @module PhysicsEngine
 * @version 1.0.0
 * @compatibility IE11+, Safari 12+, Chrome 70+, Firefox 65+
 */

/**
 * Í∏∞Î≥∏ Î¨ºÎ¶¨ ÏÉÅÏàò
 */
export const PHYSICS_CONSTANTS = {
  GRAVITY: 9.8, // m/s¬≤
  AIR_RESISTANCE: 0.98, // Í≥µÍ∏∞ Ï†ÄÌï≠ Í≥ÑÏàò
  FRICTION: 0.95, // ÎßàÏ∞∞ Í≥ÑÏàò
  MAX_VELOCITY: 500, // ÏµúÎåÄ ÏÜçÎèÑ
  MIN_VELOCITY: 0.01, // ÏµúÏÜå ÏÜçÎèÑ (Ïù¥ÌïòÎäî 0ÏúºÎ°ú Ï≤òÎ¶¨)
  COLLISION_ELASTICITY: 0.8, // Ï∂©Îèå ÌÉÑÏÑ± Í≥ÑÏàò
};

/**
 * Î≤°ÌÑ∞ ÏÉùÏÑ±
 * 
 * @param {number} x - X Ï¢åÌëú
 * @param {number} y - Y Ï¢åÌëú
 * @returns {Object} Î≤°ÌÑ∞ Í∞ùÏ≤¥
 */
export function createVector(x = 0, y = 0) {
  return { x, y };
}

/**
 * Î≤°ÌÑ∞ ÎçîÌïòÍ∏∞
 * 
 * @param {Object} v1 - Î≤°ÌÑ∞ 1
 * @param {Object} v2 - Î≤°ÌÑ∞ 2
 * @returns {Object} Í≤∞Í≥º Î≤°ÌÑ∞
 */
export function addVector(v1, v2) {
  return createVector(v1.x + v2.x, v1.y + v2.y);
}

/**
 * Î≤°ÌÑ∞ ÎπºÍ∏∞
 * 
 * @param {Object} v1 - Î≤°ÌÑ∞ 1
 * @param {Object} v2 - Î≤°ÌÑ∞ 2
 * @returns {Object} Í≤∞Í≥º Î≤°ÌÑ∞
 */
export function subtractVector(v1, v2) {
  return createVector(v1.x - v2.x, v1.y - v2.y);
}

/**
 * Î≤°ÌÑ∞ Ïä§ÏπºÎùº Í≥±
 * 
 * @param {Object} v - Î≤°ÌÑ∞
 * @param {number} scalar - Ïä§ÏπºÎùº Í∞í
 * @returns {Object} Í≤∞Í≥º Î≤°ÌÑ∞
 */
export function multiplyVector(v, scalar) {
  return createVector(v.x * scalar, v.y * scalar);
}

/**
 * Î≤°ÌÑ∞ ÌÅ¨Í∏∞ (Í∏∏Ïù¥)
 * 
 * @param {Object} v - Î≤°ÌÑ∞
 * @returns {number} Î≤°ÌÑ∞Ïùò ÌÅ¨Í∏∞
 */
export function vectorMagnitude(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

/**
 * Î≤°ÌÑ∞ Ï†ïÍ∑úÌôî
 * 
 * @param {Object} v - Î≤°ÌÑ∞
 * @returns {Object} Ï†ïÍ∑úÌôîÎêú Î≤°ÌÑ∞
 */
export function normalizeVector(v) {
  const magnitude = vectorMagnitude(v);
  if (magnitude === 0) {
    return createVector(0, 0);
  }
  return createVector(v.x / magnitude, v.y / magnitude);
}

/**
 * Îëê Ï†ê ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨
 * 
 * @param {Object} p1 - Ï†ê 1
 * @param {Object} p2 - Ï†ê 2
 * @returns {number} Í±∞Î¶¨
 */
export function distance(p1, p2) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Î¨ºÎ¶¨ Í∞ùÏ≤¥ ÏÉùÏÑ±
 * 
 * @param {Object} options - Î¨ºÎ¶¨ Í∞ùÏ≤¥ ÏòµÏÖò
 * @returns {Object} Î¨ºÎ¶¨ Í∞ùÏ≤¥
 */
export function createPhysicsObject(options = {}) {
  return {
    position: createVector(options.x || 0, options.y || 0),
    velocity: createVector(options.vx || 0, options.vy || 0),
    acceleration: createVector(options.ax || 0, options.ay || 0),
    mass: options.mass || 1,
    radius: options.radius || 10,
    width: options.width || 20,
    height: options.height || 20,
    type: options.type || 'rectangle', // rectangle, circle
    isStatic: options.isStatic || false,
    elasticity: options.elasticity || PHYSICS_CONSTANTS.COLLISION_ELASTICITY,
    friction: options.friction || PHYSICS_CONSTANTS.FRICTION,
  };
}

/**
 * Ï§ëÎ†• Ï†ÅÏö©
 * 
 * @param {Object} physicsObject - Î¨ºÎ¶¨ Í∞ùÏ≤¥
 * @param {number} gravity - Ï§ëÎ†• Í∞í (Í∏∞Î≥∏: 9.8)
 * @param {number} deltaTime - ÏãúÍ∞Ñ Í∞ÑÍ≤© (Ï¥à)
 * @returns {Object} ÏóÖÎç∞Ïù¥Ìä∏Îêú Î¨ºÎ¶¨ Í∞ùÏ≤¥
 */
export function applyGravity(physicsObject, gravity = PHYSICS_CONSTANTS.GRAVITY, deltaTime = 1/60) {
  if (physicsObject.isStatic) {
    return physicsObject;
  }

  const gravityAcceleration = createVector(0, gravity * deltaTime);
  
  return {
    ...physicsObject,
    acceleration: addVector(physicsObject.acceleration, gravityAcceleration),
  };
}

/**
 * ÏÜçÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
 * 
 * @param {Object} physicsObject - Î¨ºÎ¶¨ Í∞ùÏ≤¥
 * @param {number} deltaTime - ÏãúÍ∞Ñ Í∞ÑÍ≤© (Ï¥à)
 * @returns {Object} ÏóÖÎç∞Ïù¥Ìä∏Îêú Î¨ºÎ¶¨ Í∞ùÏ≤¥
 */
export function updateVelocity(physicsObject, deltaTime = 1/60) {
  if (physicsObject.isStatic) {
    return physicsObject;
  }

  // Í∞ÄÏÜçÎèÑÎ•º ÏÜçÎèÑÏóê Ï†ÅÏö©
  let newVelocity = addVector(
    physicsObject.velocity,
    multiplyVector(physicsObject.acceleration, deltaTime)
  );

  // Í≥µÍ∏∞ Ï†ÄÌï≠ Ï†ÅÏö©
  newVelocity = multiplyVector(newVelocity, PHYSICS_CONSTANTS.AIR_RESISTANCE);

  // ÏµúÎåÄ/ÏµúÏÜå ÏÜçÎèÑ Ï†úÌïú
  const magnitude = vectorMagnitude(newVelocity);
  if (magnitude > PHYSICS_CONSTANTS.MAX_VELOCITY) {
    newVelocity = multiplyVector(
      normalizeVector(newVelocity),
      PHYSICS_CONSTANTS.MAX_VELOCITY
    );
  } else if (magnitude < PHYSICS_CONSTANTS.MIN_VELOCITY) {
    newVelocity = createVector(0, 0);
  }

  return {
    ...physicsObject,
    velocity: newVelocity,
    acceleration: createVector(0, 0), // Í∞ÄÏÜçÎèÑ Ï¥àÍ∏∞Ìôî
  };
}

/**
 * ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
 * 
 * @param {Object} physicsObject - Î¨ºÎ¶¨ Í∞ùÏ≤¥
 * @param {number} deltaTime - ÏãúÍ∞Ñ Í∞ÑÍ≤© (Ï¥à)
 * @returns {Object} ÏóÖÎç∞Ïù¥Ìä∏Îêú Î¨ºÎ¶¨ Í∞ùÏ≤¥
 */
export function updatePosition(physicsObject, deltaTime = 1/60) {
  if (physicsObject.isStatic) {
    return physicsObject;
  }

  const newPosition = addVector(
    physicsObject.position,
    multiplyVector(physicsObject.velocity, deltaTime)
  );

  return {
    ...physicsObject,
    position: newPosition,
  };
}

/**
 * Î¨ºÎ¶¨ ÏóÖÎç∞Ïù¥Ìä∏ (Ï§ëÎ†•, ÏÜçÎèÑ, ÏúÑÏπò)
 * 
 * @param {Object} physicsObject - Î¨ºÎ¶¨ Í∞ùÏ≤¥
 * @param {number} deltaTime - ÏãúÍ∞Ñ Í∞ÑÍ≤© (Ï¥à)
 * @param {Object} options - Ï∂îÍ∞Ä ÏòµÏÖò
 * @returns {Object} ÏóÖÎç∞Ïù¥Ìä∏Îêú Î¨ºÎ¶¨ Í∞ùÏ≤¥
 */
export function updatePhysics(physicsObject, deltaTime = 1/60, options = {}) {
  let updated = physicsObject;

  // Ï§ëÎ†• Ï†ÅÏö© (ÏòµÏÖòÏúºÎ°ú ÎπÑÌôúÏÑ±Ìôî Í∞ÄÎä•)
  if (options.applyGravity !== false) {
    updated = applyGravity(updated, options.gravity, deltaTime);
  }

  // ÏÜçÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
  updated = updateVelocity(updated, deltaTime);

  // ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
  updated = updatePosition(updated, deltaTime);

  return updated;
}

/**
 * AABB (Axis-Aligned Bounding Box) Ï∂©Îèå Í∞êÏßÄ
 * 
 * @param {Object} obj1 - Î¨ºÎ¶¨ Í∞ùÏ≤¥ 1
 * @param {Object} obj2 - Î¨ºÎ¶¨ Í∞ùÏ≤¥ 2
 * @returns {boolean} Ï∂©Îèå Ïó¨Î∂Ä
 */
export function checkAABBCollision(obj1, obj2) {
  const halfWidth1 = obj1.width / 2;
  const halfHeight1 = obj1.height / 2;
  const halfWidth2 = obj2.width / 2;
  const halfHeight2 = obj2.height / 2;

  return (
    Math.abs(obj1.position.x - obj2.position.x) < halfWidth1 + halfWidth2 &&
    Math.abs(obj1.position.y - obj2.position.y) < halfHeight1 + halfHeight2
  );
}

/**
 * ÏõêÌòï Ï∂©Îèå Í∞êÏßÄ
 * 
 * @param {Object} obj1 - Î¨ºÎ¶¨ Í∞ùÏ≤¥ 1 (ÏõêÌòï)
 * @param {Object} obj2 - Î¨ºÎ¶¨ Í∞ùÏ≤¥ 2 (ÏõêÌòï)
 * @returns {boolean} Ï∂©Îèå Ïó¨Î∂Ä
 */
export function checkCircleCollision(obj1, obj2) {
  const dist = distance(obj1.position, obj2.position);
  return dist < obj1.radius + obj2.radius;
}

/**
 * Ï∂©Îèå Í∞êÏßÄ (ÌÉÄÏûÖ ÏûêÎèô ÌåêÎ≥Ñ)
 * 
 * @param {Object} obj1 - Î¨ºÎ¶¨ Í∞ùÏ≤¥ 1
 * @param {Object} obj2 - Î¨ºÎ¶¨ Í∞ùÏ≤¥ 2
 * @returns {boolean} Ï∂©Îèå Ïó¨Î∂Ä
 */
export function checkCollision(obj1, obj2) {
  if (obj1.type === 'circle' && obj2.type === 'circle') {
    return checkCircleCollision(obj1, obj2);
  }
  
  // Í∏∞Î≥∏ÏùÄ AABB (ÏÇ¨Í∞ÅÌòï ÎòêÎäî ÌòºÌï© ÌÉÄÏûÖ)
  return checkAABBCollision(obj1, obj2);
}

/**
 * Ï∂©Îèå ÏùëÎãµ (ÌÉÑÏÑ± Ï∂©Îèå)
 * 
 * @param {Object} obj1 - Î¨ºÎ¶¨ Í∞ùÏ≤¥ 1
 * @param {Object} obj2 - Î¨ºÎ¶¨ Í∞ùÏ≤¥ 2
 * @returns {Object} ÏóÖÎç∞Ïù¥Ìä∏Îêú Î¨ºÎ¶¨ Í∞ùÏ≤¥Îì§ { obj1, obj2 }
 */
export function resolveCollision(obj1, obj2) {
  // Ï†ïÏ†Å Í∞ùÏ≤¥Îäî Ï∂©Îèå ÏùëÎãµ ÏóÜÏùå
  if (obj1.isStatic && obj2.isStatic) {
    return { obj1, obj2 };
  }

  // Ï∂©Îèå Î≤°ÌÑ∞ Í≥ÑÏÇ∞
  const collisionVector = subtractVector(obj2.position, obj1.position);
  const collisionNormal = normalizeVector(collisionVector);

  // ÏÉÅÎåÄ ÏÜçÎèÑ
  const relativeVelocity = subtractVector(obj1.velocity, obj2.velocity);
  
  // Ï∂©Îèå ÏÜçÎèÑ (Î≤ïÏÑ† Î∞©Ìñ•)
  const velocityAlongNormal = 
    relativeVelocity.x * collisionNormal.x + 
    relativeVelocity.y * collisionNormal.y;

  // Ïù¥ÎØ∏ Î∂ÑÎ¶¨ Ï§ëÏù¥Î©¥ Ï∂©Îèå ÏùëÎãµ Î∂àÌïÑÏöî
  if (velocityAlongNormal > 0) {
    return { obj1, obj2 };
  }

  // ÌÉÑÏÑ± Í≥ÑÏàò (ÌèâÍ∑†)
  const elasticity = (obj1.elasticity + obj2.elasticity) / 2;

  // Ï∂©Í≤©Îüâ Í≥ÑÏÇ∞
  const impulse = -(1 + elasticity) * velocityAlongNormal / (1/obj1.mass + 1/obj2.mass);

  // ÏÜçÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
  const impulseVector = multiplyVector(collisionNormal, impulse);

  let newObj1 = obj1;
  let newObj2 = obj2;

  if (!obj1.isStatic) {
    newObj1 = {
      ...obj1,
      velocity: addVector(obj1.velocity, multiplyVector(impulseVector, 1/obj1.mass)),
    };
  }

  if (!obj2.isStatic) {
    newObj2 = {
      ...obj2,
      velocity: subtractVector(obj2.velocity, multiplyVector(impulseVector, 1/obj2.mass)),
    };
  }

  // ÏúÑÏπò Î≥¥Ï†ï (Í≤πÏπ® Ìï¥ÏÜå)
  const penetrationDepth = (obj1.radius + obj2.radius) - vectorMagnitude(collisionVector);
  if (penetrationDepth > 0) {
    const correction = multiplyVector(collisionNormal, penetrationDepth / 2);
    
    if (!obj1.isStatic) {
      newObj1 = {
        ...newObj1,
        position: subtractVector(newObj1.position, correction),
      };
    }
    
    if (!obj2.isStatic) {
      newObj2 = {
        ...newObj2,
        position: addVector(newObj2.position, correction),
      };
    }
  }

  return { obj1: newObj1, obj2: newObj2 };
}

/**
 * Í≤ΩÍ≥Ñ Ï∂©Îèå Ï≤òÎ¶¨ (ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ Îì±)
 * 
 * @param {Object} physicsObject - Î¨ºÎ¶¨ Í∞ùÏ≤¥
 * @param {Object} bounds - Í≤ΩÍ≥Ñ { minX, maxX, minY, maxY }
 * @returns {Object} ÏóÖÎç∞Ïù¥Ìä∏Îêú Î¨ºÎ¶¨ Í∞ùÏ≤¥
 */
export function constrainToBounds(physicsObject, bounds) {
  let updated = { ...physicsObject };
  let velocity = { ...physicsObject.velocity };

  // X Ï∂ï Í≤ΩÍ≥Ñ
  if (updated.position.x - updated.width/2 < bounds.minX) {
    updated.position.x = bounds.minX + updated.width/2;
    velocity.x = Math.abs(velocity.x) * updated.elasticity;
  } else if (updated.position.x + updated.width/2 > bounds.maxX) {
    updated.position.x = bounds.maxX - updated.width/2;
    velocity.x = -Math.abs(velocity.x) * updated.elasticity;
  }

  // Y Ï∂ï Í≤ΩÍ≥Ñ
  if (updated.position.y - updated.height/2 < bounds.minY) {
    updated.position.y = bounds.minY + updated.height/2;
    velocity.y = Math.abs(velocity.y) * updated.elasticity;
  } else if (updated.position.y + updated.height/2 > bounds.maxY) {
    updated.position.y = bounds.maxY - updated.height/2;
    velocity.y = -Math.abs(velocity.y) * updated.elasticity;
  }

  return {
    ...updated,
    velocity,
  };
}

/**
 * Ìûò Ï†ÅÏö©
 * 
 * @param {Object} physicsObject - Î¨ºÎ¶¨ Í∞ùÏ≤¥
 * @param {Object} force - Ìûò Î≤°ÌÑ∞ { x, y }
 * @returns {Object} ÏóÖÎç∞Ïù¥Ìä∏Îêú Î¨ºÎ¶¨ Í∞ùÏ≤¥
 */
export function applyForce(physicsObject, force) {
  if (physicsObject.isStatic) {
    return physicsObject;
  }

  // F = ma => a = F/m
  const acceleration = multiplyVector(force, 1 / physicsObject.mass);

  return {
    ...physicsObject,
    acceleration: addVector(physicsObject.acceleration, acceleration),
  };
}

/**
 * Í≥µÍ∞Ñ Î∂ÑÌï† (ÏÑ±Îä• ÏµúÏ†ÅÌôî) - Í∞ÑÎã®Ìïú Í∑∏Î¶¨Îìú Í∏∞Î∞ò
 * 
 * @param {Array} objects - Î¨ºÎ¶¨ Í∞ùÏ≤¥ Î∞∞Ïó¥
 * @param {number} cellSize - ÏÖÄ ÌÅ¨Í∏∞
 * @returns {Map} Í∑∏Î¶¨Îìú Îßµ
 */
export function createSpatialGrid(objects, cellSize = 100) {
  const grid = new Map();

  objects.forEach((obj, index) => {
    const cellX = Math.floor(obj.position.x / cellSize);
    const cellY = Math.floor(obj.position.y / cellSize);
    const cellKey = `${cellX},${cellY}`;

    if (!grid.has(cellKey)) {
      grid.set(cellKey, []);
    }
    grid.get(cellKey).push({ obj, index });
  });

  return grid;
}

/**
 * Ï∂©Îèå Í∞êÏßÄ ÏµúÏ†ÅÌôî (Í≥µÍ∞Ñ Î∂ÑÌï† ÏÇ¨Ïö©)
 * 
 * @param {Array} objects - Î¨ºÎ¶¨ Í∞ùÏ≤¥ Î∞∞Ïó¥
 * @param {number} cellSize - ÏÖÄ ÌÅ¨Í∏∞
 * @returns {Array} Ï∂©Îèå Ïåç Î∞∞Ïó¥ [{ i, j, obj1, obj2 }]
 */
export function detectCollisionsOptimized(objects, cellSize = 100) {
  const collisions = [];
  const grid = createSpatialGrid(objects, cellSize);

  // Í∞Å ÏÖÄ ÎÇ¥ÏóêÏÑú Ï∂©Îèå Í≤ÄÏÇ¨
  grid.forEach((cellObjects) => {
    for (let i = 0; i < cellObjects.length; i++) {
      for (let j = i + 1; j < cellObjects.length; j++) {
        const { obj: obj1, index: idx1 } = cellObjects[i];
        const { obj: obj2, index: idx2 } = cellObjects[j];

        if (checkCollision(obj1, obj2)) {
          collisions.push({ i: idx1, j: idx2, obj1, obj2 });
        }
      }
    }
  });

  return collisions;
}

/**
 * Î†àÏù¥Ï∫êÏä§Ìä∏ (Í¥ëÏÑ† Ìà¨ÏÇ¨) - Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ
 * 
 * @param {Object} origin - ÏãúÏûëÏ†ê
 * @param {Object} direction - Î∞©Ìñ• Î≤°ÌÑ∞
 * @param {Array} objects - Î¨ºÎ¶¨ Í∞ùÏ≤¥ Î∞∞Ïó¥
 * @param {number} maxDistance - ÏµúÎåÄ Í±∞Î¶¨
 * @returns {Object|null} Ï∂©Îèå Ï†ïÎ≥¥ ÎòêÎäî null
 */
export function raycast(origin, direction, objects, maxDistance = Infinity) {
  const normalizedDir = normalizeVector(direction);
  let closestHit = null;
  let closestDistance = maxDistance;

  objects.forEach(obj => {
    // Í∞ÑÎã®Ìïú ÏõêÌòï Ï∂©ÎèåÎßå ÏßÄÏõê
    if (obj.type !== 'circle') return;

    const toObject = subtractVector(obj.position, origin);
    const projection = toObject.x * normalizedDir.x + toObject.y * normalizedDir.y;

    if (projection < 0) return; // Îí§Ï™Ω Î∞©Ìñ•

    const closestPoint = addVector(origin, multiplyVector(normalizedDir, projection));
    const distanceToCenter = distance(closestPoint, obj.position);

    if (distanceToCenter <= obj.radius && projection < closestDistance) {
      closestDistance = projection;
      closestHit = {
        object: obj,
        distance: projection,
        point: closestPoint,
      };
    }
  });

  return closestHit;
}

export default {
  PHYSICS_CONSTANTS,
  createVector,
  addVector,
  subtractVector,
  multiplyVector,
  vectorMagnitude,
  normalizeVector,
  distance,
  createPhysicsObject,
  applyGravity,
  updateVelocity,
  updatePosition,
  updatePhysics,
  checkAABBCollision,
  checkCircleCollision,
  checkCollision,
  resolveCollision,
  constrainToBounds,
  applyForce,
  createSpatialGrid,
  detectCollisionsOptimized,
  raycast,
};

# **高度なトピック**

## **Open Matchにおけるキューの役割**

大規模なプレイヤーベースを持つ本番環境では、ゲームクライアントとOpen Matchコアの間にキューを導入することがベストプラクティスです。

技術的にはクライアントがOpen Matchと直接通信することも可能ですが、キューはスケーラビリティ、信頼性、そしてマッチメイキングリクエストのフロー管理において、いくつかの重要な利点を提供します。

以下に、堅牢なマッチメイキングアーキテクチャにおいて、キューがOpen Matchの重要なコンポーネントである理由を解説します。

#### **負荷管理とスロットリング**

キューの主な機能の一つは、ゲームクライアントから来る、潜在的に大規模でスパイク状の流入するマッチメイキングリクエストを吸収するバッファとして機能することです。 その後、キューはチケット作成をバッチ処理し、Open Matchへの1秒あたりの呼び出しをレートリミットするように設定できます（チケット作成の管理方法については、サンプル`v2/internal/mmqueue/mmqueue.go`の`Run`関数を参照してください）。 これにより、Open Matchコアがリクエストの突然の急増によって圧倒されるのを防ぎ、パフォーマンスの低下やサービスの停止を回避します。 よくある落とし穴に関するドキュメントでは、チケットの上限に達した際にリクエストを拒否するのではなく、「フロントエンドで速度を監視し、マッチメイキングへの参加のためのキューイングを実装する」ことを明確に推奨しています。

#### **デカップリングとレジリエンス**

キューはゲームクライアントをマッチメイキングサービスから切り離します。 これは、Open Matchコアが一時的に利用できなくなったり、高負荷状態になったりした場合でも、キューがマッチメイキングリクエストを保持し、後で再試行できることを意味します（`v2/internal/mmqueue/mmqueue.go`の`proxyCreateTicket`関数は再試行を伴う実装を示しています）。 これにより、システム全体が一時的な障害に対してより回復力を持つようになり、プレイヤーのリクエストが失われることがなくなります。

#### **プレイヤーエクスペリエンスの向上**

リクエストのフローを管理することで、キューはプレイヤーにより一貫性のある予測可能な体験を提供するのに役立ちます。 システムが高負荷状態のときにエラーや長い遅延に直面する可能性がある代わりに、プレイヤーをキューに入れ、推定待機時間を提供することができます。これははるかに優れたユーザーエクスペリエンスです。

要するに、小規模なテストではクライアントからOpen Matchへの直接接続がシンプルに見えるかもしれませんが、かなりの数の同時接続プレイヤーを処理する必要がある本番レベルのゲームにとって、キューは不可欠なコンポーネントです。 それはマッチメイキングシステムの安定性とスケーラビリティを確保し、プレイヤーにとってより良い体験につながります。

## **プロファイル：マッチメイキング「関数呼び出し」の引数**

Open Matchでは、**マッチメーカー**と\*\*マッチメイキング機能（MMF）\*\*の間の相互作用を、リモートプロシージャコール（RPC）として考えるのが最適です。 Open Matchコアはこの呼び出しを容易にする強力でスケーラブルなフレームワークとして機能しますが、ロジック、つまり「呼び出し」と「関数」自体はすべて開発者のものです。

このRPCの類推がどのように分解されるかを以下に示します。

#### **あなたのマッチメーカー（呼び出し元）**

あなたのマッチメーカー、特にDirectorコンポーネントが**呼び出し元**です。 その主な責任は、**いつ**マッチを作成し、**どのような種類**のマッチを望むかを決定することです。

* **引数の構築（プロファイル）**: マッチメーカーで作成する**プロファイル**は、リモート関数呼び出しのための一連の**引数**です（プロファイルの構築と使用の一つの方法については、サンプル`v2/internal/gsdirector/gsdirector.go`の`Run`関数を参照してください）。 それはマッチメイキングサイクルのパラメータを正確に定義します：「MMRが1000から1500の間で、『プレミアム』タグを持つプレイヤーのための5v5マッチが必要です」。  
* **呼び出しの開始**: マッチメーカーがOpen Matchコアで`InvokeMatchmakingFunctions`を呼び出すとき、それはRPCを実行するようなものです。 **プロファイル**（あなたの引数）と呼び出したい関数のアドレス（MMF）を渡します。

#### **Open Matchコア（RPCフレームワーク）**

Open Matchコアは、このRPCを大規模に可能にする**フレームワークまたは中間層**です。

* **引数の前処理**: MMFを呼び出す前に、Open Matchコアは重要な前処理ステップを実行します。 あなたの**プロファイル**引数を受け取り、利用可能なすべてのチケットの巨大なインメモリキャッシュを効率的にクエリし、**プロファイルのプールに一致するすべてのチケットを投入します**。  
* **リモート関数の呼び出し**: Open Matchコアはその後、MMFの`Run`メソッドを呼び出し、投入済みのプロファイルを引数として渡します。 ネットワーク通信、認証、およびデータシリアライゼーション（必要に応じてgRPCメッセージサイズの制限内に収まるようにプロファイルとチケットをチャンキングする）を処理します。 これにより、MMFは基盤となるインフラを心配することなく、純粋にそのロジックに集中できます。 これは、「マッチメーカーはマッチメイキングのみを行い、それ以外のことはしない」というコアな設計原則に沿っています。

#### **あなたのマッチメイキング機能（呼び出し先）**

あなたのMMFは、実行される\*\*リモート関数（「呼び出し先」）\*\*です。 Open Matchコアから完全に準備された引数を受け取り、最終的な特定のロジックを実行します（`v2/examples/mmf/functions/fifo/fifo.go`の`Run`関数は、MMFがリクエストを処理する一つの方法を示しています）。

* **引数の受信**: MMFは`ChunkedMmfRunRequest`メッセージのストリームを受信し、それをプールがすでに潜在的なプレイヤーで満たされた完全な**プロファイル**に再構築します。 チケットが**どのように**見つけられたかを知る必要はなく、マッチメーカーによって定義された基準に一致することだけを知っていればよいのです。  
* **コアロジックの実行**: MMFの仕事は、提供されたチケットのプールを受け取り、**マッチ**を作成することです。 ここに、チームの編成、スキルのバランス調整、またはゲームにとって「良い」マッチを定義するその他のカスタムルールなど、最もニュアンスに富んだロジックが存在します。

要約すると、開発者として、あなたは**マッチメーカー**と**MMF**の間の直接的な論理関係に焦点を当てるべきです。 それをあなたのコードがあなたの他のコードを呼び出すと考えてください。 Open Matchコアは、この相互作用をライブの本番環境で堅牢、スケーラブル、かつ信頼性の高いものにする、不可欠でありながら透明なフレームワークです。 状態、検索、およびネットワーキングを処理するため、あなたは最も重要なこと、つまりマッチメイキングロジックそのものに集中できます。

## **チケット：Open Matchコアにおける唯一の信頼できる情報源**

強力で予測可能なマッチメイキングを構築するためには、Open Matchコアが実際に**何を管理しているか**を理解することが不可欠です。 答えはシンプルかつ意図的です：**チケット**がOpen Match内部で「生きる」唯一のデータプリミティブです。 それ以外のすべては一時的な命令です。

これがあなたにとって何を意味するか？

Open Matchと対話するとき、永続的なオブジェクトである**チケット**のライフサイクルについてのみ考えればよいのです。 これはマッチメイキングの基本単位であり、プレイヤー、グループ、またはマッチを待つあらゆるエンティティを表します。

* **チケットが状態である**: Open Matchコアのステートフルなコンポーネント全体は、**チケット**の巨大なインメモリキャッシュを管理するように設計されています。 これには、フィルタリング可能な属性とアクティブ/非アクティブ状態が含まれます。  
* **レプリケーションはすべてチケットに関するものである**: 基盤となる永続化およびレプリケーションレイヤー（本番環境でのRedis使用またはテスト用のインメモリストア）は、**チケット**の状態変化を処理するために専門的に構築されています。 チケットを作成したり、アクティブ化したり、マッチが作成されたりするときのレプリケーションイベントは、単純なチケット中心の操作です：`CreateTicket`、`ActivateTicket`、`DeactivateTicket`。 これは、システムの内部データ型で明示的に示されています。  
* **その他すべてはアクションである**: **プロファイル**のようなデータ構造はOpen Matchコアには保存されません。 **プロファイル**は、RPC呼び出し（`InvokeMatchmakingFunctions`）で送信する一連の命令です。 Open Matchはこのプロファイルを単一のサイクルで使用して中央のチケットプールをフィルタリングし、その後破棄します。 プロファイル自体を保存することはありません。

#### **なぜこの設計なのか？ 焦点とスケーラビリティ**

この設計の選択は、Open Matchのコア設計原則の直接的な結果であり、2つの大きな利点を提供します。

* **明快さとシンプルさ**: 永続的なデータ型が1つしかないため、システムの動作ははるかに予測しやすく、デバッグも容易になります。 開発者であるあなたは、複雑でネストされた状態や、異なる保存済みオブジェクトがどのように相互作用するかについて心配する必要はありません。 チケットを作成し、それらを操作するための指示（プロファイル）を送信するだけです。  
* **大規模なスケーラビリティ**: このミニマリストな状態へのアプローチが、Open Matchのパフォーマンスの鍵です。 このシステムは、単一のデータ型に対するいくつかの単純な操作を、巨大なスケールで実行するために高度に最適化されています。 Open Matchコアを、唯一の「テーブル」が**チケット**用である、高性能で特殊なデータベースと考えてください。 あなたのマッチメーカーは、「アプリケーション層」として機能し、そのテーブルのデータを操作するためのクエリと指示（**プロファイル**）を送信します。 この厳格な関心の分離が、Open Matchをゲームのマッチメイキングのための堅牢でスケーラブルな基盤にしているのです。

## **チケットライフサイクル：作成したら放置、削除はしない**

Open Matchでは、**チケット**の管理はシンプルで堅牢な「作成したら放置（fire-and-forget）」モデルに従います。 チケットが一度作成されると、その削除について心配する必要はありません。 代わりに、その状態を**アクティブ**と**非アクティブ**の間で切り替えることで、マッチメイキングへの参加を制御します。

#### **1\. 作成と自動有効期限切れ**

**チケット**を作成すると、\*\*Time-to-Live（TTL）\*\*が割り当てられます。 このTTLはOpen Matchコアで設定されます（`OM_CACHE_TICKET_TTL_MS`設定経由）。

* **手動削除なし**: Open Match APIには`DeleteTicket`関数はありません。 チケットを手動で削除することはできません。  
* **自動クリーンアップ**: チケットのTTLに達すると、Open Matchの内部キャッシュ管理が自動的にそれを期限切れにし、システムから削除します。 この設計は孤立したチケットを防ぎ、別のクリーンアッププロセスを構築する必要がないため、ロジックを簡素化します。

#### **2\. 2つの状態：アクティブと非アクティブ**

**チケット**が作成された後、そのライフサイクルは2つの単純な状態を通じて管理されます。

* **非アクティブ**: `CreateTicket`を使用して最初にチケットを作成すると、それは**非アクティブ**状態で開始されます（例：`v2/internal/mmqueue/mmqueue.go`の`proxyCreateTicket`関数と、`v2/internal/omclient/omclient.go`の関連するクライアント呼び出しを参照）。 非アクティブなチケットは、マッチメイキング関数が呼び出されたときにどのプールにも含まれません。 これにより、プレイヤーが準備ができる前（例：ゲームクライアントが完全にロードされる前）に誤ってマッチングされることがなくなります。  
* **アクティブ**: `ActivateTickets` RPCを使用して、チケットを**アクティブ**状態に移行させます。 アクティブなチケットのみがマッチメイキングの対象と見なされ、MMFに送信されるプールに投入されます。

#### **3\. Open Matchによる自動非アクティブ化**

これは「作成したら放置」モデルの最も重要な部分です：**正常にマッチングされたチケットを非アクティブ化する責任はあなたにはありません**。

あなたのマッチメイキング機能（MMF）が**マッチ**をOpen Matchコアに返すと、コアサービスはあなたに代わって自動的に以下の操作を実行します。

1. **マッチ**内のすべての**チケット**を検査します。  
2. それらのチケットの**すべて**を**非アクティブ**としてマークします。

`InvokeMatchmakingFunctions`ロジックに見られるこの自動非アクティブ化は、ゲームに割り当てられたばかりのプレイヤーがすぐに別のマッチメイキングプールに戻されることがないようにします。 これは、マッチメーカーのロジックを大幅に簡素化するコア機能です。

#### **4\. 手動非アクティブ化を使用する場合**

では、なぜ`DeactivateTickets` RPCが存在するのでしょうか？ それは**例外的なシナリオ**を処理するために特別に提供されています。

最も一般的なユースケースは、プレイヤーが予期せずマッチメイキングキューを離れた場合です。 例えば、プレイヤーが：

* ゲームクライアントを閉じた。  
* あなたのサービスから切断された。  
* 明示的にマッチ検索をキャンセルした。

これらの場合、彼らの**チケット**はOpen Match内でまだ**アクティブ**です。 その後、そのプレイヤーの`TicketId`で`DeactivateTickets`を呼び出して、マッチメイキングの対象から即座に削除する必要があります。 これにより、彼らが参加できなくなったマッチに配置されるのを防ぎます。

## **長寿命チケットの取り扱い**

ゲームの設計上、プレイヤーが設定されたチケットTTLよりも長くキューで待機する必要がある場合はどうすればよいでしょうか？ 最大TTLを上書きすることはできないため、このロジックはOpen Matchコアの外部、つまり独自のアプリケーションコードで処理する必要があります。 これは例外的なユースケースのための高度なパターンです。

推奨されるアプローチは、フロントエンドサービス（例：`mmqueue`アプリケーション）に、作成したチケットの経過時間を監視させることです。

1. **有効期限の検出**: あなたのサービスがプレイヤーのチケットが有効期限に近づいていることを検出したら、サービスはアクションを起こすべきです。  
2. **新しいチケットの作成**: プログラムで`CreateTicket`を呼び出して、そのプレイヤーのために**新しい**チケットを生成する必要があります。  
3. **Extensionsにデータを保持**: 新しいチケットを作成する際、古いチケットから必要なすべての属性をコピーします。 重要なのは、**チケット**protobufメッセージの`extensions`フィールドを使用して、重要なメタデータを引き継ぐことです。 ここに、次のようなカスタムデータを保存します：  
   * `originalCreationTime`: このプレイヤーのマッチメイキングセッションで最初のチケットが作成されたときのタイムスタンプ。  
   * `requeueCount`: チケットを再作成するたびにインクリメントするカウンター。  
4. **カスタムMMFロジックの実装**: その後、あなたのマッチメイキング機能（MMF）は、`extensions`フィールド内のこのカスタムデータを理解し、それに基づいて動作するように記述されなければなりません。 例えば、あなたのMMFは次のように設計できます：  
   * `originalCreationTime`を読み取って、より長く待っているプレイヤーを優先する。  
   * 複数回再キューされたプレイヤーのスキルブラケットを広げる。

Open Matchの観点からは、単に新しいチケットが作成されているように見えるだけです。 これが「再キューされた」プレイヤーであるという認識はありません。 このパターンはOpen Matchの設計思想に完全に従っています：コアサービスはチケットのシンプルでスケーラブルなライフサイクルを処理し、ゲーム固有の複雑なキューイングロジックは完全にあなたの管理下に置かれます。

## **プールサイズ：多数の小規模なプロファイルによる並行処理を優先する**

よくある質問として、Open Matchがプールに含めることができるチケットの数に制限があるかというものがあります。 答えは**いいえ、人為的な制限はありません**。しかし、この柔軟性には重要な責任が伴います。

最適なパフォーマンスを得るためには、**非常に広範なフィルターを持つ一つの大きなプロファイルではなく、細かく分割されたプールを持つより多くのプロファイルを作成する**ようにマッチメーカーを設計すべきです。

#### **「より多くのプロファイル、より小さなプール」戦略**

単一のモノリシックなプロファイルを作成して100万のチケットを返す代わりに、より効率的でスケーラブルなパターンは、マッチメイキングロジックを多数のより小さな同時リクエストに分割することです。

例えば、「すべての北米プレイヤー」のための1つの**プロファイル**の代わりに、同時に実行される複数の、より具体的な**プロファイル**を作成すべきです。

* **プロファイル**: `us-east.4v4.skill-tier-1`  
* **プロファイル**: `us-east.4v4.skill-tier-2`  
* **プロファイル**: `us-west.4v4.skill-tier-1`  
* ...など。

#### **なぜこれがより効率的なのか**

この戦略は、Open Matchがその速度とスケーラビリティを達成する上で中心的な役割を果たします。 これは、システムの基本ドキュメントで言及されている「並行処理」設計原則の直接的な適用です。

* **並行処理が鍵**: Open Matchは多数の`InvokeMatchmakingFunctions`呼び出しを並行して処理するように設計されています。 `main.go`の実装は、各MMF呼び出しが独自のgoroutineで実行され、大規模な並列処理を可能にすることを示しています。 多数の小さなリクエストを送信することで、この並行処理の能力を活用し、プレイヤーベース全体で同時にマッチを見つけることができます。  
* **MMFのオーバーヘッドを削減**: 各MMFにより小さく、より関連性の高いチケットセットを送信する方が、著しく高速です。 あなたのMMFは、同じマッチに入る可能性のないチケットを処理するためにメモリやCPUサイクルを無駄にしません。 これにより、巨大なプールに関連する高いメモリ、ネットワーク、およびデシリアライゼーションのコストを回避できます。  
* **マッチまでの時間を短縮**: 各MMFが解決すべき問題がより小さく、よりターゲットを絞られているため、はるかに迅速に結果を返すことができます。 これは、プレイヤーがより速くゲームに参加できることを意味し、あらゆるマッチメイキングシステムの究極の目標です。  
* **チャンキングの回避**: Open Matchは4MBのgRPCメッセージ制限を超えるリクエストを自動的にチャンキングします。 これにより失敗は防げますが、データのチャンキングと再構築のプロセスは遅延を追加します。 プールを小さくターゲットを絞ることで、この制限を下回り、オーバーヘッドを完全に回避するのに役立ちます。

## **分離された評価戦略：最終的な仲裁者としてのDirector**

この並行アプローチは重要な問いを投げかけます：同時に実行されている複数のMMFが、同じプレイヤーチケットを使用したい場合はどうなるのでしょうか？

答えは、これは許容されるだけでなく、設計の意図的な部分であるということです。 重複するプールを評価する複数のMMFが並行して実行されることは、全く問題なく、しばしば望ましいことです。 これにより、必然的に同じチケットが複数の提案されたマッチに現れることになります。

これはカオスではなく、**分離された評価戦略**です。それはあなたのMMFをシンプルかつ高速に保ちます。 複雑なロックや同期ロジックを必要とせずに、受け取ったプールに基づいて可能な限り最良のマッチを独立して提案できます。

これらの競合する提案を解決する責任は、あなたのマッチメーカーのDirectorに明確に委任されます。 あなたのDirectorはこのシナリオを処理するように書かれなければなりません：

1. **競合する提案の受信**: `InvokeMatchmakingFunctions`呼び出しからマッチがストリームバックされると、Directorは異なるMMFからのこれらの独立した提案を目にします。  
2. **衝突回避と選択**: Directorはチケットの衝突を解消する責任があります（例：`v2/internal/gsdirector/gsdirector.go`の`Run`関数はチケット衝突を処理する一つのアプローチを示しています）。 **チケットA**が**マッチ1**と**マッチ2**の両方に現れた場合、あなたのコードはどちらのマッチを受け入れるかを選択しなければなりません。 単純な「先着順」ルールを持つことも、両方のマッチの品質を評価してより良い方を選ぶこともできます。  
3. **割り当てと確定**: Directorが勝利したマッチを選択したら、それらのマッチのサーバー割り当てに進みます。  
4. **未使用チケットの再アクティブ化**: これは重要な最終ステップです。 Directorが破棄したマッチについては、それらの破棄されたマッチ内の**すべてのチケットを`ActivateTickets`を呼び出して再アクティブ化する責任は、あなたのマッチメーカーにあります**（例：`v2/internal/gsdirector/gsdirector.go`のローカル関数`rejectMatch`がこれを示しています）。 これにより、それらのチケットは即座にアクティブなプールに戻り、次のマッチメイキングサイクルで再び考慮されるようになり、プレイヤーが失われることがなくなります。

この分離された評価のパターンを採用することで、MMFをシンプルで、焦点が絞られ、高速にすることができます。 そして、Directorが最終的で知的な仲裁者として機能し、プレイヤーにとってどのマッチが最適であるかについての最終決定を下し、システムが効率的で堅牢であり続けることを保証します。

## **プロファイルのスケーリング：フリート全体の戦略**

Open Matchのコア設計原則は、**マッチメイキングはプレイヤーからではなく、サーバーから流れる**というものです。 これは、利用可能なゲームサーバーが、どのような種類のマッチをホストする準備ができているかについての究極の信頼できる情報源であることを意味します。

概念的にはサーバーごとにユニークな**プロファイル**を作成することもできますが、このアプローチは数千ものフリートにはスケールしません。 代わりに、堅牢なマッチメーカー、特にその**Director**コンポーネントは、インテリジェントな集約とスライシング戦略を実装すべきです。

#### **推奨パターン：サーバーから集約されたプロファイルへ**

各サーバーが独自の理想的なプロファイルを持つと考えるのは役立ちますが、大規模環境では、多くのサーバーのニーズを単一のリクエストにまとめる方が実用的です。 推奨されるパターンは以下の通りです：

1. **サーバーニーズの読み取り**: Directorは、利用可能なゲームサーバーフリート全体を継続的にスキャンして、それらがホストするように構成されているマッチの種類を判断する必要があります。 この「信頼できる情報源」は、各サーバーインスタンスに添付されたメタデータ、またはサーバー構成を目的のマッチタイプにマッピングする中央データベースである可能性があります。  
2. **集約とカウント**: Directorのロジックは、これらのリクエストを集約し、全く同じタイプのマッチ（例：「us-eastで4v4キャプチャー・ザ・フラッグマッチをホストする準備ができているサーバーは150台」）の準備ができているサーバーの数を数えるべきです。  
3. **結合されたプロファイルの送信**: ユニークなマッチリクエストごとに、Directorは単一の結合された**プロファイル**をOpen Matchコアに送信します。  
4. **Extensionsでカウントを渡す**: 重要なことに、Directorは利用可能なサーバー数（例：`150`）を**プロファイル**の`extensions`フィールドに追加すべきです。 これにより、あなたのマッチメイキング機能（MMF）に、このタイプのマッチを最大150個作成できるという重要なコンテキストが提供されます。

#### **「ウーバープロファイル」問題と解決策：インテリジェントなスライシング**

すべての同一リクエストを単純に集約すると、それ自体の非効率性、つまり数千のサーバーを表す「ウーバープロファイル」につながる可能性があります。 1つの巨大なリクエストをMMFに送信することは、多数の小さなリクエストを送信するよりも効率が悪いです。

解決策は、Directorがこれらの大きな集約されたリクエストを、Open Matchに送信する前に、より小さく、より論理的な**プロファイル**にインテリジェントにスライスすることです。

ここであなたのゲーム固有のロジックが最も重要になります。プロファイルをスライスする一般的で効果的な方法には以下が含まれます：

* **物理的な地域**: `us-east`、`eu-west`、`sea`などの地域でサーバーをグループ化する。  
* **ゲームモード**: `デスマッチ`と`キャプチャー・ザ・フラッグ`を分離する。  
* **プラットフォーム**: ゲームがクロスプレイをサポートしていない場合、`pc`、`console`などでスライスします。

10,000台の「4v4」サーバーのリクエストを`us-east.4v4`、`eu-west.4v4`などのより詳細なプロファイルに分割することで、Open Matchの高度に並行的な設計を活用できます。 それぞれの小さな**プロファイル**は並行して処理され、プレイヤーベース全体でより高速なマッチ作成につながります。

#### **Directorが制御する**

サーバーの状態の読み取り、リクエストの集約、プロファイルのスライシング、そしてextensionsの追加というこのプロセス全体が、**あなたが書くDirectorコンポーネント内で完全に**行われることを理解することが不可欠です。 Open Matchコアは、プロファイルを受け取り、大規模に一致するチケットを見つけ、MMFを呼び出すという、その単一の専門的なタスクに集中し続けます。 サーバーフリートの認識はありません。このクリーンな関心の分離により、高性能で並行的なプレイヤー検索タスクをOpen Matchに依存しながら、洗練されたゲーム固有のフリート管理ロジックを実装する力が得られます。

## **高度なMMFパターン：単純なマッチメイキングを超えて**

マッチメイキング機能（MMF）の主な役割はマッチを作成することですが、それを**フィルタリングされたチケットセットに対してカスタムコードを実行するための汎用エンジン**として考える方がより強力です。 Open Matchコアの`InvokeMatchmakingFunctions` APIは、このコードを安全かつスケーラブルに実行するためのメカニズムです。 これにより、基本的なマッチメイキングを超えるいくつかの高度なパターンへの扉が開かれます。

#### **1\. 分析とデータ集計のためのMMF**

時には、マッチを作りたいのではなく、現在のプレイヤー人口について質問したいだけの場合があります。

* **目標**: `us-east`リージョンで`capture-the-flag`ゲームモードを待っているプレイヤーが何人いるかを知る。  
* **パターン**:  
  1. Directorは、特定の地域とゲームモードを選択するフィルターを持つプールを含む**プロファイル**を作成します。  
  2. `InvokeMatchmakingFunctions`を呼び出しますが、`count-players-mmf`という名前の特別なMMFを指します。  
  3. このMMFはチームを編成しようとはしません。その唯一の仕事は、プールで受け取ったチケットの数を数えることです。  
  4. その後、「ダミー」の**マッチ**オブジェクトを返します。プレイヤーの名簿を含む代わりに、`extensions`フィールドを使用して結果を保持します。例：`{"player_count": 127}`。  
  5. Directorはこのダミーのマッチを受け取り、それが分析用であることを認識し、そのプレイヤー数を使って戦略を決定します。たとえば、そのモードのためにより多くのサーバーを立ち上げるなどです。

#### **2\. パフォーマンス向上のためのロジックの分離（例：ロギング）**

プライマリMMFが複雑なロジックを持ち、さらに後の分析のためにすべての潜在的なマッチをログに記録する必要があると想像してください。 メインのMMFに直接ロギングを追加すると、処理が遅くなり、プレイヤーの待ち時間が増加する可能性があります。 解決策は、これらのタスクを分離することです。

* **目標**: 重要な「ホットパス」で可能な限り迅速にマッチを生成し、同時に重要でない「コールドパス」で分析のためにすべてのマッチデータをログに記録する。  
* **パターン**:  
  1. 2つのMMFを作成します：`find-matches-mmf`（高速な本番ロジック）と`log-matches-mmf`（同一のコピーですが、結果をログに記録するだけで何も返しません）。  
  2. Directorが`InvokeMatchmakingFunctions`を呼び出すとき、リクエストの`mmfs`フィールドに**両方**のMMFを投入します。  
  3. Open Matchコアは、同じ投入済みプールを両方のMMFに同時に送信します。  
  4. `find-matches-mmf`は最小限の遅延でDirectorに結果を返し、一方`log-matches-mmf`は詳細なログを書き込むという遅いタスクを独立して処理します。

#### **3\. 新しい戦略の安全なテスト（A/Bテスト）**

これは最も強力な高度なパターンの1つです。信頼できるライブのマッチメイキング戦略があるが、プレイヤー体験を損なうリスクなしに新しい戦略をテストしたい場合です。

* **目標**: 現在の`Production_MMF`に対して、実験的な`New_MMF`をライブのプレイヤートラフィックを使用してテストする。  
* **パターン**:  
  1. これは上記の同時実行パターンと同じです。Directorは`InvokeMatchmakingFunctions`を呼び出し、**`Production_MMF`と`New_MMF`の両方**が同じプロファイルで呼び出されるように要求します。  
  2. 両方のMMFは並行して実行され、それぞれが同じチケットプールから独自の提案マッチセットを作成します。 このアプローチは、**同じチケットを複数の戦略で評価し、最終決定を後で行う**ことを好むOpen Matchの設計の中核部分です。  
  3. Directorは अब、2つのマッチのストリームを受け取ります。最終的な仲裁者として機能し、実験結果をどうするかを決定できます。

     * **シャドウモード**: `New_MMF`からの結果をログに記録して、そのマッチ品質を`Production_MMF`とオフラインで比較し、そのマッチをライブプレイヤーに決して使用しない。  
     * **品質ベースのロールアウト**: MMFは**マッチ**のextensionsに`match_quality_score`を含めることができます。 Directorはその後、スコアを比較し、`New_MMF`からのマッチが`Production_MMF`からのものより明らかに優れている場合にそれを選ぶことができます。  
     * **パーセンテージベースのロールアウト**: Directorは、`New_MMF`によって提案されたマッチの、例えば1%をライブサーバーに送信することを選択でき、これにより、本格的なローンチ前に小規模で実世界のデータを収集できます。

これらのパターンは、MMFが単なる関数ではなく、柔軟なツールであることを示しています。 Open Matchの並行的でステートレスな設計を活用することで、コアのマッチメイキングロジックからクリーンに分離された、洗練された運用、分析、およびテスト戦略を実装できます。

## **Open Matchキャッシュの理解：結果整合性の実践**

本番環境では、スケーラビリティと高可用性のために、Open Matchコアの複数のインスタンスを実行します。 これらのインスタンスは、強力な分散キャッシングモデルを通じて状態を共有します。 このモデルが\*\*結果的に整合性がある（eventually consistent）\*\*ことを理解することが不可欠です。

#### **結果整合性とは何か？**

結果整合性とは、すべてのOpen Matchコアインスタンスが最終的には同一の状態に収束するものの、まったく同じミリ秒に完全に同期しているという保証はないことを意味します。 あるインスタンスが別のインスタンスより数ミリ秒早く更新を処理するかもしれません。 これはバグではなく、高性能な分散システムのための意図的で標準的な設計パターンです。 保証された瞬間的な整合性に必要な極端なオーバーヘッドよりも、可用性とスループットを優先します。

#### **レプリケーションの仕組み：中央イベントログ**

Open Matchは、すべてのチケット関連イベントの中央の順序付けられたログとしてRedis Streamsを使用することで、この状態同期を実現します。

* **ログへの書き込み**: Open MatchインスタンスがAPI呼び出し（例：`CreateTicket`）を受け取ると、中央のRedis Streamに新しいイベントを書き込みます。  
* **ログからの読み取り**: イベントを書き込んだインスタンスを含む、すべてのOpen Matchインスタンスは、常にこのストリームで新しいイベントをリッスンしています。  
* **変更の適用**: ストリームからイベントが到着すると、各インスタンスは自身のローカルのインメモリチケットキャッシュに変更を適用します。

このイベントソーシングパターンは、2つの重要な保証を提供します。

* **完全な順序**: すべてのインスタンスが、すべてのイベントをまったく同じ順序で受信し、処理します。  
* **永続性**: Redisストリームは、システムの状​​態の永続的な信頼できる情報源として機能します。

インスタンスがグローバルな状態より「進んでしまう」のを防ぐため、チケットを作成したインスタンスは、**その同じ作成イベントをRedisストリームから受け取るまで、そのチケットを自身のローカルキャッシュに追加しません**。 これにより、すべてのインスタンスが同じ公開情報に基づいて状態を更新することが保証されます。

#### **これがあなたのマッチメーカーにとって何を意味するか**

あなたのDirectorの`InvokeMatchmakingFunctions`呼び出しは、実行中のすべてのOpen Matchコアインスタンスにわたってロードバランスされます。 結果整合性のため、各インスタンスは任意の瞬間にチケットプールのわずかに異なるビューを持っている可能性があります。

ここで、重要なトレードオフを考慮する必要があります。Open Match APIでは、**単一のAPI呼び出しから複数のMMFを呼び出す**ことができます。

* **利点**: 1回の呼び出しで複数のMMFを呼び出すと、強力な保証が得られます：**その単一の操作におけるすべてのMMFは、リクエストを処理した1つのインスタンスから、チケットプールの同一でアトミックなスナップショットを見ます**。 これは、まったく同じデータセットで結果を比較する必要があるA/Bテストや分析などのタスクに最適です。  
* **トレードオフ**: この保証にはコストが伴います。複数のMMFを単一の呼び出しに強制すると、そのワークロード全体が単一のOpen Matchコアインスタンスに固定されます。 その操作については、意図的に**ロードバランシングと水平スケーラビリティの利点をバイパスしている**ことになります。

したがって、マルチMMF呼び出しパターンは、関数が同一のプールを見ることが**絶対に重要**な場合にのみ使用すべきです。 汎用の高スループットなマッチメイキングのためには、多くの場合、多数の個別の単一MMF API呼び出しを行う方が優れています。 これにより、リクエストが利用可能なすべてのOpen Matchコアインスタンスに分散され、システム全体のパフォーマンスと回復力が最大化されます。

## **Open Matchにおける時間の次元：戦略的な味方**

マッチメイキングでは、時間はしばしば敵と見なされ、プレイヤーの不満へのカウントダウンクロックと見なされます。 しかし、Open Matchの非同期で連続的なフローモデルでは、時間は強力な戦略的な味方になります。 鍵は、決定論的で世界を止めるプロセスに強制しようとするのではなく、プレイヤーの流れを受け入れることです。

#### **誤解：マッチングへの「ゲームループ」アプローチ**

分散型マッチメイキングに慣れていない開発者の間でよくある誤解は、「ゲームループ」の考え方を適用することです：すべてを停止し、利用可能なすべてのプレイヤーを処理し、マッチを作成し、そして繰り返す。

このアプローチは、ゲームエンジンで単一のフレームを描画するには最適ですが、マッチメーカーのような高スループットサービスには非効率です。 それはオンラインゲームの基本的な真実を無視しています：**新しいプレイヤーのバッチは常に到着しています**。 Open Matchは、個別のループとしてではなく、連続的な操作のストリームとして設計されています。 単一のサイクルで完全な決定論を達成するためにこの流れを止めようとすることは、非生産的であり、システムのコアな強みに反します。

#### **コアパターン：時間経過による検索の拡大**

より正しく、より強力なパターンは、プレイヤーの待ち時間とともに進化するマッチメイキングプロセスを作成することで、時間を有利に利用することです。

1. **あなたのDirectorが時間ブラケットを定義する**: Directorの主な仕事は、待機時間によってプレイヤー人口をセグメント化する**プロファイル**を作成することです。 これは、プール定義で`CreationTimeRangeFilter`を使用して行います。

2. **複数の、並行したMMFを呼び出す**: 時間ブラケットごとに、Directorは異なるルールを持つ対応するMMFを呼び出すことができます。

   * **0〜10秒待機しているプレイヤー向け**: 非常に厳しいスキルレーティング（MMR）範囲を強制し、可能な限り最高の試合品質を目指すMMF（`strict-mmf`）。  
   * **10〜30秒待機しているプレイヤー向け**: より広いMMR範囲を使用する別のMMF（`relaxed-mmf`）。  
   * **30秒以上待機しているプレイヤー向け**: 理想的なスキルバランスが満たされていなくても、プレイヤーを**いずれかの**妥当なゲームに入れることを優先する3番目のMMF（`wide-search-mmf`）。

#### **時間がより良い機会を生み出す**

この戦略は、プレイヤーの連続的な流れを受け入れます。 わずか5秒しか待っていないプレイヤーのために、質の低いマッチを作る必要はありません。 ピーク時には、あと数秒待つだけで、はるかに適したプレイヤーグループがキューに参加し、関係者全員にとってより質の高いマッチを形成できることがわかるかもしれません。

これは、マッチ品質スコアという考え方と見事に連携します。各MMFが、提案するマッチごとにスコアを算出するように設計できるのです。

例えば、wide-search-mmf（広域検索MMF）では、プレイヤーの待機時間に応じてスコアを変動させる戦略が取れます。具体的には、非常に長く待っているプレイヤーが含まれるマッチのスコアに対し、「待機ボーナス」としてスコアを10倍にする、といった設定が可能です。

そしてDirectorは、このようにして計算されたスコアを利用することで、待機時間が長いプレイヤーを含むマッチを他のマッチよりも優先し、先にゲームサーバーを割り当てることができるのです。

#### **セーフガードとしての時間：MMFタイムアウト（`OM_MMF_TIMEOUT_SECS`）**

最後に、MMFタイムアウトはマッチメイキングツールとしてではなく、重要な**セーフティネット**として見なされるべきです。 その唯一の目的は、誤動作しているMMFが無期限に実行され、マッチメーカーの安定性を損なうのを防ぐことです。

高度なパターンで議論したように、MMFは複雑な分析やシミュレーションのために、有効な実行時間が長くなるように設計される場合があります。 あなたの`OM_MMF_TIMEOUT_SECS`の値は意図的に設定されなければなりません。あなたのMMFのいずれかの**有効な**最長実行時間を慎重に評価し、タイムアウトをそれより十分に長い値に設定する必要があります。 これにより、無限ループに陥ったような、本当に壊れたMMFだけが終了させられ、正当な長時間実行タスクを妨げることなく、システムの安定性が保護されます。


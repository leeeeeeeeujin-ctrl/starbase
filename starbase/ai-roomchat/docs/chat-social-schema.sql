-- =========================================
-- Starbase AI Roomchat: Chat & Social Schema
-- =========================================
-- 실행 방법 예시:
--   psql $SUPABASE_DATABASE_URL -f chat-social-schema.sql
-- 또는 Supabase SQL Editor에 그대로 붙여넣어 실행합니다.
--
-- 1) 채팅 메시지 테이블 및 RLS 정책
-- 2) 친구 요청 / 친구 관계 테이블 및 정책
-- 3) 필수 인덱스와 트리거
-- =========================================

-- -----------------------------------------
-- 1. 채팅 메시지
-- -----------------------------------------
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  user_id uuid not null references auth.users(id) on delete cascade,
  owner_id uuid not null references auth.users(id) on delete cascade,
  username text not null,
  avatar_url text,
  hero_id uuid references public.heroes(id) on delete set null,
  scope text not null default 'global',
  target_hero_id uuid references public.heroes(id) on delete set null,
  text text not null check (length(text) between 1 and 2000),
  metadata jsonb
);

alter table public.messages enable row level security;

create policy if not exists messages_select_public
on public.messages for select
using (true);

create policy if not exists messages_insert_auth
on public.messages for insert to authenticated
with check (
  auth.uid() = user_id
  and owner_id = auth.uid()
);

create index if not exists messages_created_at_desc on public.messages (created_at desc);
create index if not exists messages_scope_created_at on public.messages (scope, created_at desc);
create index if not exists messages_hero_scope_created_at on public.messages (hero_id, scope, created_at desc);
create index if not exists messages_target_scope_created_at on public.messages (target_hero_id, scope, created_at desc);

-- -----------------------------------------
-- 2. 친구 요청 & 친구 관계
-- -----------------------------------------
create table if not exists public.friend_requests (
  id uuid primary key default gen_random_uuid(),
  requester_id uuid not null references auth.users(id) on delete cascade,
  addressee_id uuid not null references auth.users(id) on delete cascade,
  status text not null default 'pending' check (status in ('pending', 'accepted', 'declined', 'cancelled')),
  message text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists friend_requests_addressee_status on public.friend_requests (addressee_id, status);
create index if not exists friend_requests_requester_status on public.friend_requests (requester_id, status);
create unique index if not exists friend_requests_unique_pending
  on public.friend_requests (requester_id, addressee_id)
  where status = 'pending';

alter table public.friend_requests enable row level security;

create policy if not exists friend_requests_select_participants
on public.friend_requests for select
using (auth.uid() in (requester_id, addressee_id));

create policy if not exists friend_requests_insert_requester
on public.friend_requests for insert to authenticated
with check (auth.uid() = requester_id);

create policy if not exists friend_requests_update_participants
on public.friend_requests for update to authenticated
using (auth.uid() in (requester_id, addressee_id))
with check (auth.uid() in (requester_id, addressee_id));

create policy if not exists friend_requests_delete_participants
on public.friend_requests for delete to authenticated
using (auth.uid() in (requester_id, addressee_id));

create table if not exists public.friendships (
  id uuid primary key default gen_random_uuid(),
  user_id_a uuid not null references auth.users(id) on delete cascade,
  user_id_b uuid not null references auth.users(id) on delete cascade,
  since timestamptz not null default now(),
  created_at timestamptz not null default now(),
  constraint friend_pairs_canonical check (user_id_a < user_id_b)
);

create unique index if not exists friendships_unique_pair
  on public.friendships (user_id_a, user_id_b);

create index if not exists friendships_user_a on public.friendships (user_id_a);
create index if not exists friendships_user_b on public.friendships (user_id_b);

alter table public.friendships enable row level security;

create policy if not exists friendships_select_participants
on public.friendships for select
using (auth.uid() in (user_id_a, user_id_b));

create policy if not exists friendships_insert_participants
on public.friendships for insert to authenticated
with check (auth.uid() in (user_id_a, user_id_b));

create policy if not exists friendships_delete_participants
on public.friendships for delete to authenticated
using (auth.uid() in (user_id_a, user_id_b));

-- -----------------------------------------
-- 3. updated_at 자동 갱신 트리거
-- -----------------------------------------
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at := now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists friend_requests_set_updated_at on public.friend_requests;
create trigger friend_requests_set_updated_at
before update on public.friend_requests
for each row
execute function public.set_updated_at();
